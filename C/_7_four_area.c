/**可执行程序分为4个区
  *1. 代码区  text
  * 数据区  data --》静态数据和全局初始化的数据
  *
  * 未初始化数据区 bss---》未初始化数据
  *
  *
  * 2.data+bss ===>  静态区或者全局区
  *
  * 3.stack
  * 4.heap
  *
  *
  */
/*

1.理解一下程序被加载到内存中，被CPU执行的过程
	a.代码从磁盘加载到内存中，也就是程序被启动之前就已经划分为四个区域。分别加载到内存的不同地方，方便程序的执行 。找到main函数的位置，就从这个入口处开始执行 。


2.理解一下堆（heap）和 栈（stack）的区别

1.分配方式不同
	heap是由程序员手动分配和释放，在C语言中用的是malloc分配内存和free释放内存；在C++中，使用的是new分配内存，delete释放内存。
	stack是由操作系统自动分配，自动回收。

2.空间大小不同

	stack在32为机器下面一般为1MB，在我8GB内存的macbook Pro上面，STACKSIZE 的大小为8MB 。
	heap的内存分配基本上是比较充裕的，内存大小也没有什么过多的限制

3.分配效率的不同
	a.栈是机器系统直接提供支持的数据结构，计算机底层对栈结构提供支持，同时提供专门的栈寄存器用来存放栈数据，压栈，出栈都有专门的指令来支持。
	b.heap的话分配情况一般是比较复杂的，有时需要大块的内存，但是没有对应的大小，就需要在heap空间中，把各个小的heap内存串起来，这个时候也是库函数提供支持的，这样也是比较影响效率的 。

4.碎片问题

	a.heap大都是由不连续的空间集合而成，由一个记录空闲地址的链表，当申请内存是，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，每一个堆节点存放着分配空间的大小信息，这样释放的时候就可以根据地址来释放这个堆结点所指代的空间
	b.stack严格按照先进后出的规则运行，不存在乱序的内存现象。也不会造成内存的浪费和分配效率的低下

5.生长方向的不同
	
	stack的生长方向是向下的，也就是向着内存减小的方向；heap的生长方向是向上的，也就是向着内存增大的方向

*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	
	int a = 1; //栈上分配的内存，分配效率高，系统自动回收,默认是用auto 修饰的
	auto float pi = 3.1415f ;


	char * p = malloc(sizeof(char) * 32);//p 在栈上分配，后面的内存在heap上分配

	memset(p,0,32);
	strcpy(p,"alex");//"alex" 这个字符串在常量区分配的，字面常量

	printf("a = %d\npi = %f\n%s\n",a,pi,p) ;

	return 0;
}